<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>PONG</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                min-height: 100vh;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                background: #f4e4c1;
                font-family: "Courier New", monospace;
                position: relative;
                overflow: hidden;
            }

            /* Paper grain texture overlay */
            body::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                opacity: 0.4;
                background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
            }

            .container {
                position: relative;
                z-index: 1;
            }

            #gameCanvas {
                display: block;
                border: 4px solid #1a1a1a;
                border-radius: 4px;
                box-shadow: 0 4px 0 #1a1a1a, 0 8px 20px rgba(0, 0, 0, 0.2);
                background: #f9f3e3;
            }

            .score-display {
                display: flex;
                justify-content: space-between;
                width: 600px;
                margin-bottom: 20px;
                font-size: 48px;
                font-weight: bold;
                color: #1a1a1a;
                text-shadow: 2px 2px 0 #e87b35;
            }

            .score {
                padding: 10px 30px;
                background: #f9f3e3;
                border: 3px solid #1a1a1a;
                border-radius: 4px;
            }

            #resetBtn {
                margin-top: 20px;
                padding: 12px 40px;
                font-size: 20px;
                font-family: "Courier New", monospace;
                font-weight: bold;
                background: #e87b35;
                color: #1a1a1a;
                border: 3px solid #1a1a1a;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.1s ease;
                box-shadow: 0 4px 0 #1a1a1a;
                text-transform: uppercase;
                letter-spacing: 2px;
            }

            #resetBtn:hover {
                background: #f5923f;
                transform: translateY(-2px);
                box-shadow: 0 6px 0 #1a1a1a;
            }

            #resetBtn:active {
                transform: translateY(2px);
                box-shadow: 0 2px 0 #1a1a1a;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="score-display">
                <div class="score" id="scoreLeft">0</div>
                <div class="score" id="scoreRight">0</div>
            </div>
            <canvas id="gameCanvas" width="600" height="400"></canvas>
            <button id="resetBtn">Reset</button>
        </div>

        <script>
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");
            const scoreLeftEl = document.getElementById("scoreLeft");
            const scoreRightEl = document.getElementById("scoreRight");
            const resetBtn = document.getElementById("resetBtn");

            // Game constants
            const PADDLE_WIDTH = 12;
            const PADDLE_HEIGHT = 80;
            const BALL_SIZE = 14;
            const PADDLE_SPEED = 5;
            const INITIAL_BALL_SPEED = 6;
            const MAX_BALL_SPEED = 12;
            const AI_REACTION_DELAY = 0.08;

            // Colors
            const INK_COLOR = "#1a1a1a";
            const ORANGE_COLOR = "#e87b35";
            const PAPER_COLOR = "#f9f3e3";

            // Game state
            let ball, leftPaddle, rightPaddle;
            let scoreLeft = 0;
            let scoreRight = 0;
            let screenShake = { x: 0, y: 0, intensity: 0 };
            let showStamp = false;
            let stampOpacity = 0;
            let stampScale = 2;
            let particles = [];
            let lastTime = 0;

            // Initialize game objects
            function initGame() {
                ball = {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    vx: 0,
                    vy: 0,
                    speed: INITIAL_BALL_SPEED,
                };

                leftPaddle = {
                    x: 20,
                    y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                    targetY: canvas.height / 2 - PADDLE_HEIGHT / 2,
                };

                rightPaddle = {
                    x: canvas.width - 20 - PADDLE_WIDTH,
                    y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                    targetY: canvas.height / 2 - PADDLE_HEIGHT / 2,
                };

                particles = [];
            }

            // Serve the ball
            function serveBall(direction = null) {
                ball.x = canvas.width / 2;
                ball.y = canvas.height / 2;

                const angle = (Math.random() * 0.5 - 0.25) * Math.PI;
                const dir = direction || (Math.random() > 0.5 ? 1 : -1);

                ball.vx = Math.cos(angle) * ball.speed * dir;
                ball.vy = Math.sin(angle) * ball.speed;
                ball.speed = INITIAL_BALL_SPEED;

                // Trigger screen shake
                triggerScreenShake(15);
            }

            // Screen shake effect
            function triggerScreenShake(intensity) {
                screenShake.intensity = intensity;
            }

            function updateScreenShake() {
                if (screenShake.intensity > 0) {
                    screenShake.x =
                        (Math.random() - 0.5) * screenShake.intensity;
                    screenShake.y =
                        (Math.random() - 0.5) * screenShake.intensity;
                    screenShake.intensity *= 0.9;
                    if (screenShake.intensity < 0.5) {
                        screenShake.intensity = 0;
                        screenShake.x = 0;
                        screenShake.y = 0;
                    }
                }
            }

            // Show PONG stamp
            function showPongStamp() {
                showStamp = true;
                stampOpacity = 1;
                stampScale = 2;
            }

            function updateStamp() {
                if (showStamp) {
                    stampScale = Math.max(1, stampScale * 0.85);
                    if (stampScale <= 1.01) {
                        stampOpacity -= 0.02;
                        if (stampOpacity <= 0) {
                            showStamp = false;
                            stampOpacity = 0;
                        }
                    }
                }
            }

            // Particle effects
            function createParticles(x, y, count = 8) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 4;
                    particles.push({
                        x,
                        y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1,
                        size: 3 + Math.random() * 4,
                    });
                }
            }

            function updateParticles() {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.95;
                    p.vy *= 0.95;
                    p.life -= 0.03;
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                    }
                }
            }

            // AI paddle control
            function updateAI() {
                // Left paddle AI
                const leftTarget =
                    ball.vx < 0
                        ? ball.y +
                          ball.vy *
                              ((ball.x - leftPaddle.x) / Math.abs(ball.vx)) *
                              AI_REACTION_DELAY
                        : canvas.height / 2;
                leftPaddle.targetY =
                    leftTarget - PADDLE_HEIGHT / 2 + (Math.random() - 0.5) * 20;

                // Right paddle AI
                const rightTarget =
                    ball.vx > 0
                        ? ball.y +
                          ball.vy *
                              ((rightPaddle.x - ball.x) / Math.abs(ball.vx)) *
                              AI_REACTION_DELAY
                        : canvas.height / 2;
                rightPaddle.targetY =
                    rightTarget -
                    PADDLE_HEIGHT / 2 +
                    (Math.random() - 0.5) * 20;

                // Move paddles toward target
                const leftDiff = leftPaddle.targetY - leftPaddle.y;
                leftPaddle.y +=
                    Math.sign(leftDiff) *
                    Math.min(Math.abs(leftDiff), PADDLE_SPEED);

                const rightDiff = rightPaddle.targetY - rightPaddle.y;
                rightPaddle.y +=
                    Math.sign(rightDiff) *
                    Math.min(Math.abs(rightDiff), PADDLE_SPEED);

                // Clamp paddle positions
                leftPaddle.y = Math.max(
                    0,
                    Math.min(canvas.height - PADDLE_HEIGHT, leftPaddle.y)
                );
                rightPaddle.y = Math.max(
                    0,
                    Math.min(canvas.height - PADDLE_HEIGHT, rightPaddle.y)
                );
            }

            // Ball physics
            function updateBall() {
                ball.x += ball.vx;
                ball.y += ball.vy;

                // Top/bottom wall collision
                if (
                    ball.y - BALL_SIZE / 2 <= 0 ||
                    ball.y + BALL_SIZE / 2 >= canvas.height
                ) {
                    ball.vy *= -1;
                    ball.y =
                        ball.y - BALL_SIZE / 2 <= 0
                            ? BALL_SIZE / 2
                            : canvas.height - BALL_SIZE / 2;
                    createParticles(ball.x, ball.y, 4);
                    triggerScreenShake(3);
                }

                // Left paddle collision
                if (
                    ball.x - BALL_SIZE / 2 <= leftPaddle.x + PADDLE_WIDTH &&
                    ball.x + BALL_SIZE / 2 >= leftPaddle.x &&
                    ball.y >= leftPaddle.y &&
                    ball.y <= leftPaddle.y + PADDLE_HEIGHT &&
                    ball.vx < 0
                ) {
                    handlePaddleCollision(leftPaddle);
                }

                // Right paddle collision
                if (
                    ball.x + BALL_SIZE / 2 >= rightPaddle.x &&
                    ball.x - BALL_SIZE / 2 <= rightPaddle.x + PADDLE_WIDTH &&
                    ball.y >= rightPaddle.y &&
                    ball.y <= rightPaddle.y + PADDLE_HEIGHT &&
                    ball.vx > 0
                ) {
                    handlePaddleCollision(rightPaddle);
                }

                // Scoring
                if (ball.x < 0) {
                    scoreRight++;
                    scoreRightEl.textContent = scoreRight;
                    resetPoint(-1);
                } else if (ball.x > canvas.width) {
                    scoreLeft++;
                    scoreLeftEl.textContent = scoreLeft;
                    resetPoint(1);
                }
            }

            function handlePaddleCollision(paddle) {
                // Calculate hit position relative to paddle center (-1 to 1)
                const relativeY = ((ball.y - paddle.y) / PADDLE_HEIGHT) * 2 - 1;
                const bounceAngle = relativeY * (Math.PI / 4);

                // Increase speed slightly
                ball.speed = Math.min(ball.speed * 1.05, MAX_BALL_SPEED);

                // Set new velocity
                const direction = paddle === leftPaddle ? 1 : -1;
                ball.vx = Math.cos(bounceAngle) * ball.speed * direction;
                ball.vy = Math.sin(bounceAngle) * ball.speed;

                // Move ball out of paddle
                ball.x =
                    paddle === leftPaddle
                        ? leftPaddle.x + PADDLE_WIDTH + BALL_SIZE / 2
                        : rightPaddle.x - BALL_SIZE / 2;

                // Effects
                createParticles(ball.x, ball.y, 10);
                triggerScreenShake(8);
            }

            function resetPoint(lastScorer) {
                triggerScreenShake(20);
                createParticles(canvas.width / 2, canvas.height / 2, 15);

                setTimeout(() => {
                    serveBall(-lastScorer);
                }, 500);
            }

            // Draw functions
            function drawGrain() {
                ctx.save();
                ctx.globalAlpha = 0.03;
                for (let i = 0; i < 1000; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? "#000" : "#fff";
                    ctx.fillRect(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        1,
                        1
                    );
                }
                ctx.restore();
            }

            function drawCenterLine() {
                ctx.save();
                ctx.setLineDash([15, 15]);
                ctx.strokeStyle = INK_COLOR;
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 0);
                ctx.lineTo(canvas.width / 2, canvas.height);
                ctx.stroke();
                ctx.restore();
            }

            function drawPaddle(paddle) {
                ctx.save();

                // Shadow
                ctx.fillStyle = "rgba(0,0,0,0.2)";
                ctx.fillRect(
                    paddle.x + 3,
                    paddle.y + 3,
                    PADDLE_WIDTH,
                    PADDLE_HEIGHT
                );

                // Main paddle
                ctx.fillStyle = INK_COLOR;
                ctx.fillRect(paddle.x, paddle.y, PADDLE_WIDTH, PADDLE_HEIGHT);

                // Highlight
                ctx.fillStyle = ORANGE_COLOR;
                ctx.fillRect(paddle.x + 2, paddle.y + 2, 3, PADDLE_HEIGHT - 4);

                ctx.restore();
            }

            function drawBall() {
                ctx.save();

                // Trail effect
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = ORANGE_COLOR;
                ctx.beginPath();
                ctx.arc(
                    ball.x - ball.vx * 2,
                    ball.y - ball.vy * 2,
                    BALL_SIZE / 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                ctx.globalAlpha = 0.1;
                ctx.beginPath();
                ctx.arc(
                    ball.x - ball.vx * 4,
                    ball.y - ball.vy * 4,
                    BALL_SIZE / 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                // Shadow
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = "#000";
                ctx.beginPath();
                ctx.arc(ball.x + 3, ball.y + 3, BALL_SIZE / 2, 0, Math.PI * 2);
                ctx.fill();

                // Main ball
                ctx.globalAlpha = 1;
                ctx.fillStyle = ORANGE_COLOR;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, BALL_SIZE / 2, 0, Math.PI * 2);
                ctx.fill();

                // Outline
                ctx.strokeStyle = INK_COLOR;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Highlight
                ctx.fillStyle = "#fff";
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(ball.x - 3, ball.y - 3, 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            function drawParticles() {
                particles.forEach((p) => {
                    ctx.save();
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = ORANGE_COLOR;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }

            function drawStamp() {
                if (!showStamp) return;

                ctx.save();
                ctx.globalAlpha = stampOpacity;
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(stampScale, stampScale);
                ctx.rotate(-0.1);

                // Stamp background
                ctx.fillStyle = ORANGE_COLOR;
                ctx.fillRect(-100, -40, 200, 80);

                // Stamp border
                ctx.strokeStyle = INK_COLOR;
                ctx.lineWidth = 4;
                ctx.strokeRect(-100, -40, 200, 80);

                // Text
                ctx.fillStyle = INK_COLOR;
                ctx.font = "bold 60px Courier New";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("PONG", 0, 0);

                ctx.restore();
            }

            // Main game loop
            function gameLoop(timestamp) {
                const deltaTime = timestamp - lastTime;
                lastTime = timestamp;

                // Update
                updateScreenShake();
                updateStamp();
                updateParticles();
                updateAI();
                updateBall();

                // Draw
                ctx.save();
                ctx.translate(screenShake.x, screenShake.y);

                // Clear with paper color
                ctx.fillStyle = PAPER_COLOR;
                ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);

                drawGrain();
                drawCenterLine();
                drawPaddle(leftPaddle);
                drawPaddle(rightPaddle);
                drawBall();
                drawParticles();
                drawStamp();

                ctx.restore();

                requestAnimationFrame(gameLoop);
            }

            // Reset game
            function resetGame() {
                scoreLeft = 0;
                scoreRight = 0;
                scoreLeftEl.textContent = "0";
                scoreRightEl.textContent = "0";

                initGame();
                showPongStamp();

                setTimeout(() => {
                    serveBall();
                }, 300);
            }

            // Event listeners
            resetBtn.addEventListener("click", resetGame);

            // Start game
            initGame();
            showPongStamp();
            setTimeout(() => {
                serveBall();
            }, 300);
            requestAnimationFrame(gameLoop);
        </script>
    </body>
</html>
