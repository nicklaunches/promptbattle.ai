<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vintage Popcorn Machine</title>
    <style>
        :root {
            --bg-color: #f5f0e6;
            --accent-color: #ff6b35;
            --ink-color: #1a1a1a;
            --glass-color: rgba(255, 255, 255, 0.2);
            --ui-font: 'Courier New', Courier, monospace;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--ink-color);
            font-family: var(--ui-font);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none;
        }

        h1 {
            margin: 10px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            border-bottom: 3px solid var(--accent-color);
            padding-bottom: 5px;
        }

        #canvas-container {
            position: relative;
            box-shadow: 10px 10px 0px rgba(0,0,0,0.1);
            border: 4px solid var(--ink-color);
            background: #fff;
            cursor: pointer;
        }

        canvas {
            display: block;
        }

        /* Controls Area */
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            background: #fff;
            padding: 15px;
            border: 3px solid var(--ink-color);
            box-shadow: 5px 5px 0px var(--accent-color);
        }

        button {
            background: var(--bg-color);
            border: 2px solid var(--ink-color);
            padding: 10px 20px;
            font-family: var(--ui-font);
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.1s;
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: inset 2px 2px 0px rgba(0,0,0,0.1);
        }

        button.accent {
            background: var(--accent-color);
            color: #fff;
            border-color: var(--ink-color);
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        label {
            font-size: 0.8em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 120px;
            height: 10px;
            background: var(--bg-color);
            border: 2px solid var(--ink-color);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            border: 2px solid var(--ink-color);
            cursor: pointer;
        }

        .instruction {
            margin-top: 10px;
            font-size: 0.8rem;
            opacity: 0.7;
            font-style: italic;
        }
    </style>
</head>
<body>

    <h1>Cinema Popper No. 1</h1>

    <div id="canvas-container">
        <canvas id="popperCanvas" width="600" height="500"></canvas>
    </div>

    <div class="controls">
        <div class="slider-group">
            <label for="heatSlider">HEAT INTENSITY</label>
            <input type="range" id="heatSlider" min="1" max="100" value="50">
        </div>

        <button id="btnDoor">Open Door</button>
        <button id="btnReset">Reset</button>
    </div>

    <div class="instruction">Click the glass to add kernels</div>

    <script>
        const canvas = document.getElementById('popperCanvas');
        const ctx = canvas.getContext('2d');

        // --- Configuration ---
        const CONFIG = {
            gravity: 0.4,
            kettleY: 150,
            kettleWidth: 140,
            kettleHeight: 60,
            machineLeft: 100,
            machineRight: 500,
            machineFloor: 450,
            popForce: 9,
            colorKernel: '#e6c229',
            colorPopcorn: '#fdfdfd',
            colorAccent: '#ff6b35',
            colorInk: '#1a1a1a'
        };

        // --- State ---
        let heatLevel = 0.5; // 0 to 1
        let isDoorOpen = false;
        let particles = [];
        let steamParticles = [];
        let butterDrops = [];
        let shakeOffset = 0;
        let lightPulse = 0;
        let lastTime = 0;

        // --- Interaction ---
        const heatSlider = document.getElementById('heatSlider');
        const btnDoor = document.getElementById('btnDoor');
        const btnReset = document.getElementById('btnReset');
        const container = document.getElementById('canvas-container');

        heatSlider.addEventListener('input', (e) => {
            heatLevel = e.target.value / 100;
        });

        btnDoor.addEventListener('click', () => {
            isDoorOpen = !isDoorOpen;
            btnDoor.innerText = isDoorOpen ? "Close Door" : "Open Door";
            btnDoor.classList.toggle('accent');
        });

        btnReset.addEventListener('click', () => {
            particles = [];
            steamParticles = [];
            butterDrops = [];
        });

        // Click to add kernels
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            addKernels(5); // Add 5 kernels per click

            // Visual feedback
            container.style.transform = "scale(0.99)";
            setTimeout(() => container.style.transform = "scale(1)", 50);
        });

        // --- Classes ---

        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'kernel' or 'popcorn'

                // Physics
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.radius = type === 'kernel' ? 4 : 8 + Math.random() * 4;
                this.angle = Math.random() * Math.PI * 2;
                this.vAngle = (Math.random() - 0.5) * 0.2;

                // State
                this.isPopped = type === 'popcorn';
                this.popTimer = 100 + Math.random() * 500; // Time until pop
                this.heatAbsorbed = 0;
                this.butterLevel = 0; // 0 to 1
            }

            update() {
                // Apply Gravity
                this.vy += CONFIG.gravity;

                // Heat Logic (Kernels only)
                if (!this.isPopped) {
                    // Shaking effect based on heat
                    if (this.y > CONFIG.kettleY && this.y < CONFIG.kettleY + CONFIG.kettleHeight) {
                        this.vx += (Math.random() - 0.5) * heatLevel;
                        this.vy += (Math.random() - 0.5) * heatLevel;
                    }

                    // Accumulate heat
                    this.heatAbsorbed += heatLevel;
                    if (this.heatAbsorbed > this.popTimer) {
                        this.pop();
                    }
                }

                // Update Position
                this.x += this.vx;
                this.y += this.vy;
                this.angle += this.vAngle;

                // Friction / Air Resistance
                this.vx *= 0.99;
                this.vy *= 0.99;

                this.checkCollisions();
            }

            pop() {
                this.isPopped = true;
                this.type = 'popcorn';
                this.radius = 10 + Math.random() * 5; // Expand
                // Explosive force Upwards
                this.vy = -(CONFIG.popForce + (heatLevel * 5));
                this.vx = (Math.random() - 0.5) * 10;

                // Create Steam
                createSteam(this.x, this.y);
            }

            checkCollisions() {
                const r = this.radius;

                // --- Kettle Bounds (Only for Kernels or newly popped inside) ---
                // We simplify the kettle as a box in the center
                const kLeft = (canvas.width / 2) - (CONFIG.kettleWidth / 2);
                const kRight = (canvas.width / 2) + (CONFIG.kettleWidth / 2);
                const kTop = CONFIG.kettleY;
                const kBottom = CONFIG.kettleY + CONFIG.kettleHeight;

                if (!this.isPopped) {
                    // Keep kernels inside kettle
                    if (this.x < kLeft + r) { this.x = kLeft + r; this.vx *= -0.5; }
                    if (this.x > kRight - r) { this.x = kRight - r; this.vx *= -0.5; }
                    if (this.y > kBottom - r) { this.y = kBottom - r; this.vy *= -0.5; }
                    if (this.y < kTop + r) { this.y = kTop + r; this.vy *= -0.5; }
                    return;
                }

                // --- Popcorn Wall Bounds ---

                // Floor
                let floorY = CONFIG.machineFloor;

                // If Door Open, particles on right side can fall out
                let isOutside = false;
                if (isDoorOpen && this.x > CONFIG.machineRight) {
                    isOutside = true;
                    floorY = canvas.height + 100; // Fall off screen
                }

                if (this.y > floorY - r) {
                    this.y = floorY - r;
                    this.vy *= -0.4; // Bounce
                    this.vx *= 0.8;  // Friction on floor
                }

                // Ceiling
                if (this.y < 50 + r) {
                    this.y = 50 + r;
                    this.vy *= -0.5;
                }

                // Left Wall
                if (this.x < CONFIG.machineLeft + r) {
                    this.x = CONFIG.machineLeft + r;
                    this.vx *= -0.6;
                }

                // Right Wall (Glass)
                // If door is closed, hard wall. If open, gap at bottom.
                if (!isDoorOpen) {
                    if (this.x > CONFIG.machineRight - r) {
                        this.x = CONFIG.machineRight - r;
                        this.vx *= -0.6;
                    }
                } else {
                    // Door is open, act as wall only above a certain height?
                    // Let's just remove the wall logic if x > boundary to let them fly,
                    // but we need to prevent them from clipping back IN if they are out.
                    if (this.x > CONFIG.machineRight - r && this.x < CONFIG.machineRight + r && !isOutside) {
                        // Pass through
                    }
                }

                // --- Kettle Outer Collision (Popcorn shouldn't fall back IN easily) ---
                // Simplified: Just check if hitting bottom of kettle from below or sides
                // (Omitted for simplicity to keep frame rate high, assume they bounce off or around)
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                if (this.type === 'kernel') {
                    ctx.fillStyle = CONFIG.colorKernel;
                    ctx.strokeStyle = CONFIG.colorInk;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.radius, this.radius * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    // Draw Popcorn (Fluffy cloud shape)
                    ctx.fillStyle = this.butterLevel > 0.5 ? '#fff3b0' : CONFIG.colorPopcorn;
                    ctx.strokeStyle = CONFIG.colorInk;
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    // Draw 3 overlapping circles for "cloud" look
                    ctx.arc(0, -3, this.radius * 0.6, 0, Math.PI * 2);
                    ctx.arc(-4, 3, this.radius * 0.5, 0, Math.PI * 2);
                    ctx.arc(4, 3, this.radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Internal detail line
                    ctx.beginPath();
                    ctx.moveTo(-2, -2);
                    ctx.quadraticCurveTo(0, 0, 2, -2);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        class Steam {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vy = -1 - Math.random() * 2;
                this.vx = (Math.random() - 0.5) * 1;
                this.life = 1.0;
                this.size = 5 + Math.random() * 10;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
                this.size += 0.2;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life * 0.4;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Butter {
            constructor() {
                this.x = CONFIG.machineLeft + Math.random() * (CONFIG.machineRight - CONFIG.machineLeft);
                this.y = 50; // Top of cabinet
                this.vy = 2 + Math.random();
                this.size = 3;
                this.active = true;
            }
            update() {
                this.y += this.vy;
                // Check collision with popcorn
                for (let p of particles) {
                    if (p.isPopped) {
                        const dx = this.x - p.x;
                        const dy = this.y - p.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < p.radius + this.size) {
                            p.butterLevel = 1; // Butter the popcorn
                            this.active = false;
                            break;
                        }
                    }
                }
                if (this.y > CONFIG.machineFloor) this.active = false;
            }
            draw() {
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- Core Functions ---

        function addKernels(count) {
            const centerX = canvas.width / 2;
            for(let i=0; i<count; i++) {
                particles.push(new Particle(
                    centerX + (Math.random()-0.5) * 40,
                    CONFIG.kettleY + 10,
                    'kernel'
                ));
            }
        }

        function createSteam(x, y) {
            for(let i=0; i<3; i++) {
                steamParticles.push(new Steam(x, y));
            }
        }

        function solveStacking() {
            // Simple iterative relaxation for stacking (pseudo-physics)
            // This is computationally expensive, so we limit iterations or only check nearby
            // For a JS demo, O(N^2) is risky if N > 300.

            const activeParticles = particles.filter(p => p.isPopped);

            // Only run if reasonable count
            if (activeParticles.length > 400) return;

            for (let i = 0; i < activeParticles.length; i++) {
                for (let j = i + 1; j < activeParticles.length; j++) {
                    const p1 = activeParticles[i];
                    const p2 = activeParticles[j];

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distSq = dx * dx + dy * dy;
                    const minDist = p1.radius + p2.radius;

                    if (distSq < minDist * minDist && distSq > 0) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;

                        // Separate
                        const force = overlap * 0.5; // Stiff spring

                        // Apply position correction
                        p1.x -= nx * force;
                        p1.y -= ny * force;
                        p2.x += nx * force;
                        p2.y += ny * force;

                        // Add friction if touching
                        p1.vx *= 0.95;
                        p2.vx *= 0.95;
                    }
                }
            }
        }

        // --- Drawing the Machine ---

        function drawMachineBackground() {
            // Legs
            ctx.strokeStyle = CONFIG.colorInk;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(CONFIG.machineLeft + 20, CONFIG.machineFloor);
            ctx.lineTo(CONFIG.machineLeft + 20, CONFIG.machineFloor + 40);
            ctx.moveTo(CONFIG.machineRight - 20, CONFIG.machineFloor);
            ctx.lineTo(CONFIG.machineRight - 20, CONFIG.machineFloor + 40);
            ctx.stroke();

            // Cabinet Back
            ctx.fillStyle = '#e8dfd0';
            ctx.fillRect(CONFIG.machineLeft, 50, CONFIG.machineRight - CONFIG.machineLeft, CONFIG.machineFloor - 50);

            // Warming Light Glow (Pulse)
            const pulse = 0.5 + Math.sin(Date.now() / 200) * 0.1;
            const grad = ctx.createRadialGradient(
                canvas.width/2, 80, 10,
                canvas.width/2, 150, 200
            );
            grad.addColorStop(0, `rgba(255, 107, 53, ${pulse * 0.6})`);
            grad.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(CONFIG.machineLeft, 50, CONFIG.machineRight - CONFIG.machineLeft, CONFIG.machineFloor - 50);

            // Back Grid/Lines for Retro look
            ctx.strokeStyle = 'rgba(0,0,0,0.05)';
            ctx.lineWidth = 2;
            for(let i = CONFIG.machineLeft; i < CONFIG.machineRight; i+=20) {
                ctx.beginPath();
                ctx.moveTo(i, 50);
                ctx.lineTo(i, CONFIG.machineFloor);
                ctx.stroke();
            }
        }

        function drawKettle() {
            // Kettle Hanger
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, 50); // Top center
            ctx.lineTo(canvas.width/2, CONFIG.kettleY);
            ctx.stroke();

            // Shaking Kettle
            ctx.save();
            if (heatLevel > 0.1) {
                shakeOffset = (Math.random() - 0.5) * (heatLevel * 4);
            } else {
                shakeOffset = 0;
            }

            ctx.translate(canvas.width/2 + shakeOffset, CONFIG.kettleY);

            // Kettle Pot
            ctx.fillStyle = '#d1d1d1'; // Metal
            ctx.strokeStyle = CONFIG.colorInk;
            ctx.lineWidth = 3;

            // Trapezoid shape
            ctx.beginPath();
            ctx.moveTo(-CONFIG.kettleWidth/2, 0); // Top Left
            ctx.lineTo(CONFIG.kettleWidth/2, 0);  // Top Right
            ctx.lineTo(CONFIG.kettleWidth/2 - 10, CONFIG.kettleHeight); // Bottom Right
            ctx.lineTo(-CONFIG.kettleWidth/2 + 10, CONFIG.kettleHeight); // Bottom Left
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Accent stripe
            ctx.fillStyle = CONFIG.colorAccent;
            ctx.fillRect(-CONFIG.kettleWidth/2 + 5, 20, CONFIG.kettleWidth - 10, 15);

            // Lid (Visual only, pops up?)
            // We'll just draw a line for the lid hinge
            ctx.beginPath();
            ctx.moveTo(-CONFIG.kettleWidth/2, 0);
            ctx.lineTo(CONFIG.kettleWidth/2, 0);
            ctx.lineWidth = 4;
            ctx.stroke();

            ctx.restore();
        }

        function drawForeground() {
            // Cabinet Frame (Front)
            ctx.strokeStyle = CONFIG.colorInk;
            ctx.lineWidth = 5;
            ctx.strokeRect(CONFIG.machineLeft, 50, CONFIG.machineRight - CONFIG.machineLeft, CONFIG.machineFloor - 50);

            // Top Decoration
            ctx.fillStyle = CONFIG.colorAccent;
            ctx.fillRect(CONFIG.machineLeft - 10, 20, (CONFIG.machineRight - CONFIG.machineLeft) + 20, 30);
            ctx.strokeRect(CONFIG.machineLeft - 10, 20, (CONFIG.machineRight - CONFIG.machineLeft) + 20, 30);

            // Glass Reflections
            ctx.save();
            ctx.beginPath();
            ctx.rect(CONFIG.machineLeft, 50, CONFIG.machineRight - CONFIG.machineLeft, CONFIG.machineFloor - 50);
            ctx.clip();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 20;
            ctx.beginPath();
            ctx.moveTo(CONFIG.machineLeft + 20, CONFIG.machineFloor);
            ctx.lineTo(CONFIG.machineLeft + 150, 50);
            ctx.stroke();

            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.moveTo(CONFIG.machineLeft + 160, CONFIG.machineFloor);
            ctx.lineTo(CONFIG.machineLeft + 250, 50);
            ctx.stroke();

            // Door Logic
            if (isDoorOpen) {
                // Draw open door angled out
                ctx.save();
                ctx.translate(CONFIG.machineRight, 50);
                ctx.rotate(0.3); // Rotate door
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.strokeStyle = CONFIG.colorInk;
                ctx.lineWidth = 3;
                ctx.fillRect(0, 0, 100, CONFIG.machineFloor - 50);
                ctx.strokeRect(0, 0, 100, CONFIG.machineFloor - 50);
                ctx.restore();
            }

            ctx.restore();
        }

        // --- Main Loop ---

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawMachineBackground();

            // Kettle (Back half visual - logic handles collision)
            drawKettle();

            // Butter Logic (Random drop)
            if (Math.random() < 0.01) {
                butterDrops.push(new Butter());
            }
            butterDrops = butterDrops.filter(b => b.active);
            butterDrops.forEach(b => {
                b.update();
                b.draw();
            });

            // Particles
            // Draw unpopped kernels first (behind popped)
            particles.forEach(p => {
                if(!p.isPopped) p.draw();
            });

            // Update Physics
            particles.forEach(p => p.update());
            solveStacking(); // Resolve overlaps

            // Draw Popcorn
            particles.forEach(p => {
                if(p.isPopped) p.draw();
            });

            // Clean up off-screen particles
            if (particles.length > 600) {
                particles.shift(); // Remove oldest to prevent lag
            }

            // Steam
            steamParticles = steamParticles.filter(s => s.life > 0);
            steamParticles.forEach(s => {
                s.update();
                s.draw();
            });

            drawForeground();

            requestAnimationFrame(loop);
        }

        // Start
        addKernels(20);
        loop();

    </script>
</body>
</html>